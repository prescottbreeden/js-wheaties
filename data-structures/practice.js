// ---------------------
// Concepts / Strategies
// ---------------------
// Sort
// BFS / DFS / Binary Search
// Shortest Path
// Dynamic Programming
// Divide and Conquer
// Hashtable (dictionary)
// Multiple Pointer (e.g. array partitioning, moving window)

// ----------------
// Data Structures
// ----------------
// SLL :: (number, SLL) -> SLL
// addfront :: number -> SLL -> SLL
// addback :: number -> SLL -> SLL
// removefront :: SLL -> SLL
// removeback :: SLL -> SLL
// map :: fn -> SLL -> SLL

// STACK
// push
// pop
// peek

// QUEUE (reg/circuluar)
// enqueue
// dequeue

// HEAP (max/min/priority)
// insert
// extract root

// BST
// insert :: number -> bst -> bst
// min :: bst -> a
// max :: bst -> a
// deleteNode :: a -> bst -> bst
// contains :: a -> bst -> boolean
// filter :: predicate -> bst -> [a]
// preorder :: bst -> [a]
// inorder :: bst -> [a]
// postorder :: bst -> [a]
// bfs :: bst -> [a]
// dfs :: bst -> [a]
// mintree :: [a] -> bst
// valuesAtDepths :: bst -> { [string]: a }
// bstIsBalanced :: bst -> boolean
// -- heights of two subtrees of any node never differ by more than 1
// validBst :: bst -> boolean
// successor :: a -> bst

// GRAPH (un/directed, un/weighted)
// addvertex
// addedge (directed)
// bfs
// dfs
// shorted path (e.g. djikstra)
// topological sort

// TRIE
// insert
// remove
// suggestions

// Special Alogs
// A*
// Dijkstras
